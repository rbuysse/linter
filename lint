#!/usr/bin/env python3

import os
import sys
import yaml

found_files = []

class LintError(Exception):
    def __init__(self, line, error):
        self.line = line
        self.error = error

    def __str__(self):
        return f"{self.line}: {self.error}"


def check_if_dir(input):
    """ Check if script arguments are a directory or a file.
        If it's a directory, call find_yaml_files.
        If it's a file, add it to found_files.
    """
    if os.path.isdir(input):
        find_yaml_files(input)
    else:
        found_files.append(input)


def check_comment_ignore(line, rule):
    """ Check if the line should be ignored based on the ignore rule."""
    if "# disable" in line and f"{rule}" in line:
        return True
    return False    


def help():
    print("Usage: lint <path>")
    print()
    print("Recursively search for yaml files in the given directory and lint them.")
    print("<path> can be a directory, a file or a list of either/both.")
    sys.exit(1)


def find_yaml_files(repo_path):
    """ Recursively search for yaml files in the given directory.
        Add file paths to the found_files list.
    """
    print(f"Searching for yaml files in '{repo_path}'")
    for root, dirs, files in os.walk(repo_path):
        for file in files:
            if file.endswith(".yaml") or file.endswith(".yml"):
                found_files.append(os.path.join(root, file))

def lint_file(file_path):
    errors = []
    with open(file_path, 'r') as file:
        try:
            yaml_data = yaml.safe_load_all(file)
        except yaml.YAMLError as e:
            print(e)

        errors.append(external_secret_creation_policy(yaml_data, file_path))

        if errors:
            print_error(file_path)
            for error in errors:
                print_error(error)
            print()
            return 1
        else:
            return 0

def lint_lines(file_path):
    errors = []
    line_number = 0
    with open(file_path, 'r') as file:
        for line in file:
            line_number += 1
            line = line.lower()
            # Search for disallowed Kind types
            errors.extend(disallowed_kinds(line, line_number))
            
    if errors:
        print_error(file_path)
        for error in errors:
            print_error(error)
        print()
        return 1
    else:
        return 0


def print_error(error):
    print(f"\033[91m{error}\033[0m")


# rules
def disallowed_kinds(line, line_number):
    """ Look for disallowed kubernetes objects."""
    errors = []
    disallowed_objects = ["BuildConfig", "CatalogSourceConfig", "ClusterRole", 
                          "ClusterRoleBinding", "Role", "RoleBinding", "Subscription"]
    if any(k in line for k in ["kind:", "Kind"]):
        for obj in disallowed_objects:
            if obj.lower() in line:
                if check_comment_ignore(line, "disallowed_kinds"):
                    pass
                else:
                    errors.append(f"'Kind: {obj}' is not allowed.")
    return [LintError(line_number, error) for error in errors]

def external_secret_creation_policy(data, file_path):
    """ Check if the ExternalSecret has a creationPolicy of 'Merge' """
    if data['kind'] == "ExternalSecret":
        try:
            creation_policy = data['spec']['target']['creationPolicy']
        except KeyError:
            print_error("creationPolicy missing. ExternalSecrets must have a " \
                        "creationPolicy of \"Merge\"")
            return 1

        if data['spec']['target']['creationPolicy'] != 'Merge':
            print_error("ExternalSecrets must have a creationPolicy of \"Merge\"")
            return 1

        return 0

def external_secret_refresh(data, file_path):
    if data.get('kind') == 'ExternalSecret':
        # check if spec: refreshInterval: exists, if so, check to see if it's set to '1h'
        if data.get('spec').get('refreshInterval') != '1h':
            print_error("ExternalSecrets must have a refreshInterval of 1h")
            return 1

def main():
    file_errors = 0
    line_errors = 0
    if len(sys.argv) < 2:
        help()

    for arg in sys.argv[1:]:
        if not os.path.exists(arg):
            print_error(f"Path '{arg}' does not exist.")
            sys.exit(1)
        check_if_dir(arg)

    for file in found_files:
        file_errors += lint_file(file)
        line_errors += lint_lines(file)

    if line_errors != 0 or file_errors != 0:
        print_error("Found lint")
        sys.exit(1)

main()
